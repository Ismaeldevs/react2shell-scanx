"""
Verificadores de vulnerabilidad usando patrón Strategy.
"""
from abc import ABC, abstractmethod
import re
import requests


class VulnerabilityChecker(ABC):
    """Clase base abstracta para verificadores de vulnerabilidad."""
    
    @abstractmethod
    def is_vulnerable(self, response: requests.Response) -> bool:
        """
        Verifica si una respuesta indica vulnerabilidad.
        
        Args:
            response: Respuesta HTTP del servidor
            
        Returns:
            True si es vulnerable, False en caso contrario
        """
        pass


class SafeVulnerabilityChecker(VulnerabilityChecker):
    """
    Verificador de vulnerabilidad mediante side-channel.
    Detecta sin ejecutar código en el servidor.
    """
    
    def is_vulnerable(self, response: requests.Response) -> bool:
        """
        Verifica vulnerabilidad usando detección por side-channel.
        
        Args:
            response: Respuesta HTTP del servidor
            
        Returns:
            True si es vulnerable, False en caso contrario
        """
        # Verificar status 500 y presencia del digest específico
        if response.status_code != 500 or 'E{"digest"' not in response.text:
            return False

        # Verificar mitigaciones de Vercel/Netlify (no son hallazgos válidos)
        server_header = response.headers.get("Server", "").lower()
        has_netlify_vary = "Netlify-Vary" in response.headers
        is_mitigated = (
            has_netlify_vary
            or server_header == "netlify"
            or server_header == "vercel"
        )

        return not is_mitigated


class RCEVulnerabilityChecker(VulnerabilityChecker):
    """
    Verificador de vulnerabilidad mediante ejecución de PoC RCE.
    Verifica el resultado de la operación matemática en el header.
    """
    
    def is_vulnerable(self, response: requests.Response) -> bool:
        """
        Verifica vulnerabilidad mediante detección de RCE exitoso.
        
        Args:
            response: Respuesta HTTP del servidor
            
        Returns:
            True si es vulnerable (resultado 11111 presente), False en caso contrario
        """
        # Buscar el header X-Action-Redirect con el valor esperado
        redirect_header = response.headers.get("X-Action-Redirect", "")
        return bool(re.search(r'.*/login\?a=11111.*', redirect_header))


class VulnerabilityCheckerFactory:
    """Factory para crear verificadores de vulnerabilidad."""
    
    @staticmethod
    def create_checker(check_mode: str) -> VulnerabilityChecker:
        """
        Crea instancia de verificador según el modo.
        
        Args:
            check_mode: Modo de verificación ('safe', 'rce', 'vercel_waf')
            
        Returns:
            Instancia de VulnerabilityChecker
            
        Raises:
            ValueError: Si el modo es inválido
        """
        if check_mode == "safe":
            return SafeVulnerabilityChecker()
        elif check_mode in ("rce", "vercel_waf"):
            # Ambos modos RCE y Vercel WAF usan la misma verificación
            return RCEVulnerabilityChecker()
        else:
            raise ValueError(f"Modo de verificación inválido: {check_mode}")
